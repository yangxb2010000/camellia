package com.netease.nim.camellia.redis.proxy.hbase;

import com.netease.nim.camellia.hbase.CamelliaHBaseTemplate;
import com.netease.nim.camellia.redis.CamelliaRedisTemplate;
import com.netease.nim.camellia.redis.proxy.command.AuthCommandProcessor;
import com.netease.nim.camellia.redis.proxy.command.Command;
import com.netease.nim.camellia.redis.proxy.command.CommandInvoker;
import com.netease.nim.camellia.redis.proxy.command.async.bigkey.BigKeyHunter;
import com.netease.nim.camellia.redis.proxy.command.async.bigkey.CommandBigKeyMonitorConfig;
import com.netease.nim.camellia.redis.proxy.command.async.hotkey.CommandHotKeyMonitorConfig;
import com.netease.nim.camellia.redis.proxy.command.async.hotkey.HotKeyHunter;
import com.netease.nim.camellia.redis.proxy.command.async.hotkey.HotKeyHunterManager;
import com.netease.nim.camellia.redis.proxy.command.async.spendtime.CommandSpendTimeConfig;
import com.netease.nim.camellia.redis.proxy.conf.CamelliaServerProperties;
import com.netease.nim.camellia.redis.proxy.enums.RedisCommand;
import com.netease.nim.camellia.redis.proxy.monitor.*;
import com.netease.nim.camellia.redis.proxy.netty.ChannelInfo;
import com.netease.nim.camellia.redis.proxy.reply.ErrorReply;
import com.netease.nim.camellia.redis.proxy.reply.Reply;
import com.netease.nim.camellia.redis.proxy.util.*;
import io.netty.channel.ChannelHandlerContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 *
 * Created by caojiajun on 2020/02/27.
 */
public class RedisHBaseCommandInvoker implements CommandInvoker {

    private static final Logger logger = LoggerFactory.getLogger(RedisHBaseCommandInvoker.class);

    private final Map<String, Method> methodMap = new HashMap<>();
    private final RedisHBaseCommandProcessor processor;
    private final AuthCommandProcessor authCommandProcessor;

    private CommandSpendTimeConfig commandSpendTimeConfig;
    private HotKeyHunter hotKeyHunter;
    private BigKeyHunter bigKeyHunter;

    public RedisHBaseCommandInvoker(CamelliaRedisTemplate redisTemplate, CamelliaHBaseTemplate hBaseTemplate, CamelliaServerProperties serverProperties) {
        processor = new RedisHBaseCommandProcessor(redisTemplate, hBaseTemplate);

        if (serverProperties.isMonitorEnable()) {
            MonitorCallback monitorCallback = ConfigInitUtil.initMonitorCallback(serverProperties);
            RedisMonitor.init(serverProperties.getMonitorIntervalSeconds(), serverProperties.isCommandSpendTimeMonitorEnable(), monitorCallback);
        }

        Class<? extends IRedisHBaseCommandProcessor> clazz = IRedisHBaseCommandProcessor.class;
        CommandMethodUtil.initCommandFinderMethods(clazz, methodMap);

        int monitorIntervalSeconds = serverProperties.getMonitorIntervalSeconds();
        CommandSpendTimeConfig commandSpendTimeConfig = ConfigInitUtil.initCommandSpendTimeConfig(serverProperties);
        if (commandSpendTimeConfig != null) {
            SlowCommandMonitor.init(monitorIntervalSeconds);
            this.commandSpendTimeConfig = commandSpendTimeConfig;
        }
        CommandHotKeyMonitorConfig commandHotKeyMonitorConfig = ConfigInitUtil.initCommandHotKeyMonitorConfig(serverProperties);
        if (commandHotKeyMonitorConfig != null) {
            HotKeyMonitor.init(monitorIntervalSeconds);
            HotKeyHunterManager hotKeyHunterManager = new HotKeyHunterManager(commandHotKeyMonitorConfig);
            this.hotKeyHunter = hotKeyHunterManager.get(null, null);
        }
        CommandBigKeyMonitorConfig commandBigKeyMonitorConfig = ConfigInitUtil.initBigKeyMonitorConfig(serverProperties);
        if (commandBigKeyMonitorConfig != null) {
            BigKeyMonitor.init(monitorIntervalSeconds);
            this.bigKeyHunter = new BigKeyHunter(commandBigKeyMonitorConfig);
        }
        this.authCommandProcessor = new AuthCommandProcessor(ConfigInitUtil.initClientAuthProvider(serverProperties));
    }

    @Override
    public void invoke(ChannelHandlerContext ctx, ChannelInfo channelInfo, List<Command> commands) {
        if (commands.isEmpty()) return;
        for (Command command : commands) {
            if (RedisMonitor.isMonitorEnable()) {
                RedisMonitor.incr(null, null, command.getName());
            }
            Reply reply = null;
            long startTime = 0;
            if (RedisMonitor.isCommandSpendTimeMonitorEnable()) {
                startTime = System.nanoTime();
            }
            try {
                if (command.getRedisCommand() == RedisCommand.AUTH) {
                    reply = authCommandProcessor.invokeAuthCommand(channelInfo, command);
                    ctx.writeAndFlush(reply);
                    debugLog(reply, channelInfo);
                } else if (command.getRedisCommand() == RedisCommand.QUIT) {
                    ctx.close();
                    return;
                } else {
                    if (authCommandProcessor.isPasswordRequired() && channelInfo.getChannelStats() == ChannelInfo.ChannelStats.NO_AUTH) {
                        ctx.writeAndFlush(ErrorReply.NO_AUTH);
                        debugLog(ErrorReply.NO_AUTH, channelInfo);
                        continue;
                    }
                    Method method = methodMap.get(command.getName());
                    if (method == null) {
                        logger.warn("only support zset relevant commands, return NOT_SUPPORT, command = {}, consid = {}", command.getName(), channelInfo.getConsid());
                        ctx.writeAndFlush(ErrorReply.NOT_SUPPORT);
                        debugLog(ErrorReply.NOT_SUPPORT, channelInfo);
                        return;
                    }
                    if (hotKeyHunter != null) {
                        hotKeyHunter.incr(command.getKeys());
                    }
                    if (bigKeyHunter != null) {
                        bigKeyHunter.checkRequest(command);
                    }
                    //
                    reply = (Reply) CommandInvokerUtil.invoke(method, command, processor);
                    ctx.writeAndFlush(reply);
                    debugLog(reply, channelInfo);
                    //
                    if (bigKeyHunter != null) {
                        bigKeyHunter.checkReply(command, reply);
                    }
                }
            } catch (Throwable e) {
                reply = handlerError(e, command.getName());
                ctx.writeAndFlush(reply);
                debugLog(reply, channelInfo);
            } finally {
                if (startTime > 0) {
                    long spendNanoTime = System.nanoTime() - startTime;
                    RedisMonitor.incrCommandSpendTime(null, null, command.getName(), spendNanoTime);
                    if (this.commandSpendTimeConfig != null && spendNanoTime > this.commandSpendTimeConfig.getSlowCommandThresholdNanoTime()) {
                        double spendMillis = spendNanoTime / 1000000.0;
                        long slowCommandThresholdMillisTime = this.commandSpendTimeConfig.getSlowCommandThresholdMillisTime();
                        SlowCommandMonitor.slowCommand(command, spendMillis, slowCommandThresholdMillisTime);
                        if (this.commandSpendTimeConfig.getSlowCommandMonitorCallback() != null) {
                            try {
                                this.commandSpendTimeConfig.getSlowCommandMonitorCallback().callback(command, reply,
                                        spendMillis, slowCommandThresholdMillisTime);
                            } catch (Exception e) {
                                ErrorLogCollector.collect(RedisHBaseCommandInvoker.class, "SlowCommandCallback error", e);
                            }
                        }
                    }
                }
            }
        }
    }

    private Reply handlerError(Throwable e, String msg) {
        e = ErrorHandlerUtil.handler(e);
        String message = ErrorHandlerUtil.redisErrorMessage(e);
        String log = "invoke error, msg = " + msg + ",e=" + e.toString();
        ErrorLogCollector.collect(RedisHBaseCommandInvoker.class, log);
        return new ErrorReply(message);
    }

    private void debugLog(Reply reply, ChannelInfo channelInfo) {
        if (logger.isDebugEnabled()) {
            logger.debug("send reply = {}, consid = {}", reply.getClass().getSimpleName(), channelInfo.getConsid());
        }
    }
}
